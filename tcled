#!/usr/bin/tclsh
#ed in tcl
#mute (m@san.aq) 2015 public domain
# vim: set ai ts=4 sw=4 sts=0 noet:

set promptStr {*}
set bufLines {{}}
set errMsg {}
set dbg_addrlist {}
set curLine 0
set modeH 1
set silent 0
set dirty 0
set prompt 0

proc readfile {file line} {
	global bufLines curLine silent

	set fd [open "$file" "r+"]
	fconfigure $fd -translation binary
	set buf [read $fd]
	close $fd

	set bufLines [split $buf "\n"]
	set curLine [last_line]

	if {!$silent} { puts [string length $buf] }
	unset buf
}

proc pushaddr {raddrlist addr} {
	upvar $raddrlist addrlist
	# addr1 and addr2 are like a stack. first assign 1, then assign 2.
	# then, shift left each time.
	if {[llength $addrlist] < 2} {
		lappend addrlist $addr
	} else {
		set addrlist [list [lindex $addrlist 1] $addr]
	}
}

proc get_buffer {start end} {
	global bufLines
	
	return [lrange $bufLines [expr {$start - 1}] [expr {$end - 1}]]
}

proc last_line {} {
	global bufLines

	return [expr {[llength $bufLines] - 1}]
}

proc get_offset {line rp} {
	upvar $rp p
	set minus 0
	set off 0

	if {[string match {[-+]} [string index $line $p]]} {
		if {[string index $line $p] eq "-"} {set minus 1}
		incr p
	}

	# dont skip spaces here. POSIX wants "3 ---- 2" = 1
	if {[regexp {^[0-9]+} [string range $line $p end] off]} {
		incr p [string length $off]
		if {$minus} { set off [expr {0 - $off}] }
	} else {
		set off [expr {$minus ? -1 : 1}]
	}

	while {[string is space -strict [string index $line $p]]} { incr p }
	return $off
}

proc get_addr {line rp addr} {
	global curLine marks
	upvar $rp p
	set marks(t) 3
	set off 0

	set ch [string index $line $p]

	switch -glob -- $ch {
		{'} {
			incr p
			set m [string index $line $p]
			if {[string is lower -strict $m] == 0} {
				setErr {Invalid mark character}
				return -1
			} elseif {[info exists marks($m)] == 0} {
				setErr {Nonexistant mark}
				return -1
			} else {
				set addr $marks($m)
				incr p
			}
		}
		{.} { incr p; set addr $curLine }
		{$} { incr p; set addr [last_line] }
		[0-9] {
			regexp {[0-9]+} [string range $line $p end] num
			incr p [expr {[string length $num]}]
			set addr $num
		}
		{[-+]} { set addr $curLine }
		,  { return $addr }
		\; { return $addr }
		default { return $addr }
	}

	while {[string is space -strict [string index $line $p]]} { incr p }
	# next is offset. not another addr.
	if {[string match {['.$/?]} [string index $line $p]]} {
		setErr {Invalid address offset}
		return -1
	}
	while {[string match {[-+0-9]} [string index $line $p]]} {
		set off [get_offset $line p]
		set addr [expr {$addr + $off}]
	}
	return $addr
}

proc parse_line {line} {
	global curLine dbg_addrlist

	set addrlist {}
	set first 1
	set addr ""
	set p 0

	while {[string is space -strict [string index $line $p]]} { incr p }
	# if <cr> alone it's +1p
	# can't do in doCommand without fall-through
	if {[string range $line $p end] eq ""} { return [parse_line "+1p"] }

	while 1 {
		set addr [get_addr $line p $addr]
		if {$addr == -1} { return -1 }
		set ch [string index $line $p]
		if {$addr eq "" && $first} {
			if {$ch eq ","} {
				pushaddr addrlist 1
				set addr [last_line]
			} elseif {$ch eq ";"} {
				pushaddr addrlist $curLine
				set addr [last_line]
			}
		} else {
			pushaddr addrlist $addr
		}
		# should get_addr pop off the separator like get_off does? so we
		# would check for a valid start char rather than end char?
		if {![string match {[,;]} $ch]} break
		set first 0
		if {$ch eq ";"} { set curLine $addr }
		incr p
		while {[string is space -strict [string index $line $p]]} { incr p }
	}
	set cmd [string range $line $p end]
	doCommand $cmd $addrlist
	set dbg_addrlist $addrlist ;# so we can see previous addrlist in Debug command
}

proc setErr {msg} {
	global errMsg modeH

	set errMsg $msg
	if {$modeH != 0} { putErr }
	puts "?"
}

proc putErr {} {
	global errMsg

	puts stderr $errMsg
}

# maybe this shouldn't all go together
proc check_addrlist {raddrlist defaddr1 defaddr2 {allowzero 0}} {
	global curLine
	upvar $raddrlist addrlist

	if {$defaddr1 eq "" && [llength $addrlist] != 0} {
		setErr {Address not expected}
		return -1
	}
	switch [llength $addrlist] {
		0 {set addrlist [list $defaddr1 $defaddr2]}
		1 {pushaddr addrlist [lindex $addrlist 0]}
		2 {}
	}
	foreach {start end} $addrlist break
	if {$start == 0 && ! $allowzero} {
		setErr {Invalid address}
		return -1
	}
	if {$start > $end || $start < 0 || $end > [last_line]} {
		setErr {Invalid address range}
		return -1
	}

	return 0
}

proc doCommand {cmd addrlist} {
	global curLine bufLines dirty modeH prompt dbg_addrlist

	set rest  ""
	set suffix ""

	regexp {(.)((?:[nlp]?)*)(.*)} $cmd -> cmd suffix rest

	switch -glob -- $cmd {
		"" -
		[lnp] {
			if {[check_addrlist addrlist $curLine $curLine] != 0} {return -1}
			foreach {start end} $addrlist break
			if {$cmd eq "n" || [string first n $suffix] != -1} { set n [expr {$start - 1}] } else { set n "" }
			foreach line [get_buffer $start $end] {
				if {$n ne ""} { puts "[incr n]	$line" } else { puts $line }
			}
		}
		D { puts "addrlist=$addrlist prevaddrlist=$dbg_addrlist modeH=$modeH dirty=$dirty prompt=$prompt curLine=$curLine last=[last_line]" }
		H { set modeH [expr {!$modeH}] }
		h {
			putErr
		}
		i {
			foreach {start end} $addrlist break
			while {[gets stdin line] != -1 && $line ne "."} {
				lappend ibuf $line
			}
			incr end -1 ;# we're preincrementing
			foreach line $ibuf {
				set bufLines [linsert $bufLines [incr end] $line]
			}	
			set dirty 1
		}
		P { set prompt [expr {!$prompt}] }
		q {
			if {$dirty == 1} {
				setErr {Warning: modified buffer}
				incr dirty
				return 0
			} else {
				exit
			}
		}
		Q { exit }
		= {
			if {[check_addrlist addrlist 1 [last_line] 1] != 0} {return -1}
			foreach {start end} $addrlist break
			puts "$end"
		}
		* { setErr "Invalid command"; return -1 }
	}
	#set curLine $end
}

proc usage {} {
	puts {Usage: ed [-p prompt] [-s] file}
}

for {set i 0} {$i < $::argc} {incr i} {
	set a [lindex $::argv $i]
	switch -glob -- $a {
		-p {
			incr i
			set promptStr [lindex $::argv $i]
			set prompt 1
		}
		-s { set silent 1 }
		-* {
			puts "unk option: $a"
		}
		* {
			set fileName $a
			break
		}
	}
}

if {[info exists fileName]} {
	readfile $fileName 0
}

while 1 {
	if {$prompt} {
		puts -nonewline $promptStr
		flush stdout
	}
	if {[gets stdin line] == -1} break
	parse_line $line
}
