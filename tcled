#!/usr/bin/tclsh
#ed in tcl
#mute (m@san.aq) 2015 public domain
# vim: set ai ts=4 sw=4 sts=0 noet:

# global pollution :(
set promptStr {*}
set bufLines {{}}
set errMsg {}
set dbg_addrlist {}
set curLine 0
set modeH 1
set silent 0
set dirty 0
set prompt 0
set fileName ""
set addr1 ""
set addr2 ""

proc readfile {file line} {
	global bufLines curLine silent

	set fd [open "$file" "r+"]
	#fconfigure $fd -translation binary
	set buf [read $fd]
	close $fd

	set bufLines [split $buf "\n"]
	set curLine [last_line]

	if {!$silent} { puts [string length $buf] }
	unset buf
}

proc writefile {fn} {
	global fileName addr1 addr2 silent

	if {$fn eq ""} {
		setErr "No current filename"
		return -1
	} elseif {$fileName eq ""} {
		set fileName $fn
	}
	set fd [open "$fn" "w"]
	#fconfigure $fd -translation binary

	set buf [join [get_buffer $addr1 $addr2] "\n"]
	puts $fd $buf
	if {!$silent} { puts [string length $buf] }
}

proc get_buffer {start end} {
	global bufLines
	
	return [lrange $bufLines [expr {$start - 1}] [expr {$end - 1}]]
}

proc last_line {} {
	global bufLines

	return [expr {[llength $bufLines] - 1}]
}

proc get_addr {line rp addr} {
	global curLine marks
	upvar $rp p

	while {[string is space -strict [string index $line $p]]} { incr p }

	switch -glob -- [string index $line $p] {
		{'} {
			incr p
			set m [string index $line $p]
			if {[string is lower -strict $m] == 0} {
				setErr {Invalid mark}
				return -1
			} elseif {[info exists marks($m)] == 0} {
				setErr {Nonexistant mark}
				return -1
			} else {
				set addr $marks($m)
				incr p
			}
		}
		{.} { incr p; set addr $curLine }
		{$} { incr p; set addr [last_line] }
		[0-9] {
			regexp {[0-9]+} [string range $line $p end] num
			incr p [expr {[string length $num]}]
			set addr $num
		}
		{[-+]} { set addr $curLine }
		,  { return $addr }
		\; { return $addr }
		default { return $addr }
	}

	# offset loop. [-+ \t] sep
	while 1 {
		while {[string is space -strict [string index $line $p]]} { incr p }
		# not time for another addr here
		if {[string match {['.$/?]} [string index $line $p]]} {
			setErr {Invalid address offset}
			return -1
		}
		if {![string match {[-+0-9]} [string index $line $p]]} break

		# dont skip spaces here. POSIX wants "3 ---- 2" = 1
		if {[regexp {^([-+]?)([0-9]*)} [string range $line $p end] off sign digits]} {
			incr p [string length $off]
			if {$digits eq ""} {set off [expr 0 $sign 1]}
			incr addr $off
		}
	}
	return $addr
}

proc parse_line {line} {
	global curLine dbg_addrlist addr1 addr2

	set addr1 ""
	set addr2 ""
	set addr  ""
	set first 1
	set p 0

	# if <cr> alone it's +1p
	# can't do in doCommand without fall-through
	if {[string trim $line] eq ""} { return [parse_line "+1p"] }

	while 1 {
		if {[set addr [get_addr $line p $addr]] == -1} { return -1 }
		set ch [string index $line $p]
		if {$addr eq "" && $first} {
			if {$ch eq ","} {
				foreach {addr1 addr2} [list $addr2 1] break
				set addr [last_line]
			} elseif {$ch eq ";"} {
				foreach {addr1 addr2} [list $addr2 $curLine] break
				set addr [last_line]
			}
		} else {
			foreach {addr1 addr2} [list $addr2 $addr] break
		}
		if {$ch eq ";"} {
			set curLine $addr
		} elseif {$ch ne ","} break
		incr p ;# only incr if it was a sep, else we gobble up cmd
		set first 0
	}
	set cmd [string range $line $p end]
	doCommand $cmd
	set dbg_addrlist "($addr1,$addr2)" ;# so we can see previous addrlist in Debug command
}

proc setErr {msg} {
	global errMsg modeH

	set errMsg $msg
	if {$modeH != 0} { putErr }
	puts "?"
}

proc putErr {} {
	global errMsg

	puts stderr $errMsg
}

#no args means allow no addresses (ie: f command)
#if you only want 1 address, specify both as same thing
proc check_addrs {{defaddr1 ""} {defaddr2 ""} {allowzero 0}} {
	global addr1 addr2

	# this if block confused the shit out of me for some reason
	# fill addr2, then addr1, then addr2, and so on..
	if {$addr2 eq ""} {
		set addr2 $defaddr2
		set addr1 $defaddr1
	} elseif {$defaddr2 eq ""} {
		setErr {Address not expected}
		return -1
	} elseif {$addr1 eq ""} {
		set addr1 $addr2
	}
	if {$defaddr2 eq ""} {return 0} ;#uh, rethink this FIXME
	if {$addr1 == 0 && ! $allowzero} {
		setErr {Invalid address}
		return -1
	}
	if {$addr1 > $addr2 || $addr1 < 0 || $addr2 > [last_line]} {
		setErr {Invalid address range}
		return -1
	}

	return 0
}

proc doCommand {cmd} {
	global curLine bufLines dirty modeH prompt dbg_addrlist addr1 addr2 marks
	global fileName

	set rest  ""
	set suffix ""

	regexp {(.)((?:[nlp]?)*)(.*)} $cmd -> cmd suffix rest

	switch -glob -- $cmd {
		"" -
		[lnp] {
			if {[check_addrs $curLine $curLine] != 0} {return -1}
			if {$cmd eq "n" || [string first n $suffix] != -1} {
				set n [expr {$addr1 - 1}]
			} else {
				set n ""
			}
			foreach line [get_buffer $addr1 $addr2] {
				if {$n ne ""} { puts "[incr n]\t$line" } else { puts $line }
			}
		}
		[ai] {
			if {[check_addrs $curLine $curLine 1] != 0} {return -1}
			set addr $addr2 ;# shouldnt really change our global huh?
			#intermediate buf incase they bail? or nah?
			set ibuf {}
			while {[gets stdin line] != -1 && $line ne "."} {
				lappend ibuf $line
			}
			if {$cmd == "i"} {
				if {$addr == 0} {incr addr}
				incr addr -1 ;#insert before
			}
			incr addr -1 ;# we're preincrementing
			foreach line $ibuf {
				set bufLines [linsert $bufLines [incr addr] $line]
			}
			incr addr ;# 0>1 indexing
			set curLine $addr
			set dirty 1
		}
		D { puts "addrlist=($addr1,$addr2) prevaddrlist=$dbg_addrlist modeH=$modeH dirty=$dirty prompt=$prompt curLine=$curLine last=[last_line] fileName=$fileName" }
		f {
			if {[check_addrs] != 0} {return -1}
			set p 0
			while {[string is space -strict [string index $rest $p]]} { incr p }
			if {$p < 1} {
				setErr {Unexpected command suffix}
				return -1
			}
			set fileName [string range $rest $p end]
		}
		H {
			if {[check_addrs] != 0} {return -1}
			set modeH [expr {!$modeH}]
		}
		h {
			if {[check_addrs] != 0} {return -1}
			putErr
		}
		k {
			if {[check_addrs $curLine $curLine] != 0} {return -1}
			set m [string index $rest 0]
			if {[string is lower -strict $m] != 1} {
				setErr {Invalid mark}
				return -1
			}
			set marks($m) $addr2
		}
		P {
			if {[check_addrs] != 0} {return  -1}
			set prompt [expr {!$prompt}]
		}
		q {
			if {[check_addrs] != 0} {return -1}
			if {$dirty == 1} {
				setErr {Warning: modified buffer}
				incr dirty
				return 0
			} else {
				exit
			}
		}
		Q {
			if {[check_addrs] != 0} {return -1}
			exit
		}
		w {
			if {[check_addrs 1 [last_line]] != 0} {return -1}
			if {[regexp {(?:[[:space:]]+)([^[:space:]]+)} $rest -> fn]} {
				writefile $fn
			} else {
				writefile $fileName
			}
			set dirty 0
		}
		= {
			if {[check_addrs 1 [last_line] 1] != 0} {return -1}
			puts "$addr2"
		}
		* {
			setErr "Invalid command"
			return -1
		}
	}
}

proc usage {} {
	puts {Usage: ed [-p prompt] [-s] file}
}

for {set i 0} {$i < $::argc} {incr i} {
	set a [lindex $::argv $i]
	switch -glob -- $a {
		-p {
			incr i
			set promptStr [lindex $::argv $i]
			set prompt 1
		}
		-s { set silent 1 }
		-* {
			puts "unk option: $a"
		}
		* {
			set fileName $a
			break
		}
	}
}

if {$fileName ne ""} {
	readfile $fileName 0
}

while 1 {
	if {$prompt} {
		puts -nonewline $promptStr
		flush stdout
	}
	if {[gets stdin line] == -1} break
	parse_line $line
}
